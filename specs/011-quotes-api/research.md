# Research: Quotes API

**Generated by**: `/speckit.plan` Phase 0

## Overview

This document resolves all technical questions and documents research findings for the Quotes API implementation. Based on the Pax8 Quoting Endpoints v2 OpenAPI specification.

---

## Research Topics

### 1. Quote Schema (Pax8 Quoting API v2)

**Question**: What is the exact schema for Quote from the Pax8 Quoting API v2?

**Decision**: Use the official Pax8 Quoting Endpoints v2 OpenAPI schema.

**Findings**: From `https://devx.pax8.com/openapi/6761fd80721228003dd0af1a`:

```typescript
interface Quote {
  id: string;                           // UUID
  status: QuoteStatus;                  // enum
  client: ClientDetails;                // nested object
  partner: PartnerDetails;              // nested object
  lineItems: LineItem[];                // array
  totals: InvoiceTotals;                // nested object
  attachments: Attachment[];            // array
  referenceCode: string;                // auto-generated
  introMessage: string;                 // optional
  termsAndDisclaimers: string;          // optional
  expiresOn: string;                    // ISO 8601 datetime
  published: boolean;                   // whether shared
  publishedOn: string | null;           // ISO 8601 datetime
  createdBy: string;                    // user ID
  createdOn: string;                    // ISO 8601 datetime
  respondedOn: string | null;           // ISO 8601 datetime
  revokedOn: string | null;             // ISO 8601 datetime
  acceptedBy: AcceptedBy | null;        // when accepted
  quoteRequestId: string | null;        // optional UUID
}

type QuoteStatus = 
  | 'draft' 
  | 'assigned' 
  | 'sent' 
  | 'closed' 
  | 'declined' 
  | 'accepted' 
  | 'changes_requested' 
  | 'expired';
```

**Rationale**: Official OpenAPI is the authoritative source per constitution.

**Alternatives Considered**: None - official API is definitive.

---

### 2. Line Item Types (Discriminated Union)

**Question**: How should the three line item types (Standard, Custom, UsageBased) be modeled?

**Decision**: Discriminated union with `type` literal field.

**Findings**: From official OpenAPI:

```typescript
// Base fields shared by all line item payloads
interface BaseAddLineItemPayload {
  billingTerm: BillingTerm;
  quantity?: number;
  effectiveDate?: string;      // ISO 8601
  note?: string;               // max 2000 chars
  sectionId?: string;          // UUID
  commitmentTerm?: CommitmentTerm;
  relationships?: LineItemRelationship[];
}

// Standard: linked to existing product
interface AddStandardLineItemPayload extends BaseAddLineItemPayload {
  type: 'Standard';
  productId: string;           // UUID (required)
  price?: AmountCurrency;
}

// Custom: partner-defined product
interface AddCustomLineItemPayload extends BaseAddLineItemPayload {
  type: 'Custom';
  productName: string;         // max 255 chars (required)
  productSku?: string;         // max 100 chars
  cost: AmountCurrency;        // required
  price: AmountCurrency;       // required
}

// UsageBased: product with usage configuration
interface AddUsageBasedLineItemPayload extends BaseAddLineItemPayload {
  type: 'UsageBased';
  productId: string;           // UUID (required)
  cost: AmountCurrency;        // required
  usageBased: UsageBasedConfig; // required
}

// Combined type
type AddLineItemPayload = 
  | AddStandardLineItemPayload 
  | AddCustomLineItemPayload 
  | AddUsageBasedLineItemPayload;
```

**Rationale**: 
1. Discriminated unions provide compile-time type safety
2. `type` literal allows TypeScript to narrow types automatically
3. User explicitly chose this approach in clarifications

**Alternatives Considered**:
- Generic object with optional fields: Less type-safe, no compile-time narrowing
- Separate functions per type: More API surface, less flexible for batch operations

---

### 3. v2 API Base Path Handling

**Question**: How should the client handle `/v2/` vs `/v1/` base paths?

**Decision**: Single client with internal path switching per API method.

**Findings**: 
- Existing `Pax8Client.request(path, init)` uses `new URL(path, this.config.baseUrl)` 
- For v2 endpoints, prefix paths with `/v2/` instead of `/v1/`
- No configuration change needed - just different path strings

```typescript
// v1 API example (existing)
await this.client.request('/v1/companies');

// v2 API (quotes)
await this.client.request('/v2/quotes');
```

**Rationale**: 
1. Minimal code change
2. Same authentication/retry behavior
3. User explicitly chose single client approach

**Alternatives Considered**:
- Separate v2 client class: Duplication of auth/retry logic
- Base URL configuration: Would break existing v1 usage

---

### 4. v2 Pagination Pattern

**Question**: How should `limit/page` pagination differ from existing `page/size`?

**Decision**: Create new pagination options and validators specific to v2.

**Findings**: From Pax8 Quoting API:
- `limit`: Number of items per page (1-50, default 10)
- `page`: Page number (1-indexed, unlike v1 which is 0-indexed)

```typescript
interface ListQuotesOptions {
  limit?: number;              // 1-50, default 10
  page?: number;               // 1-indexed (differs from v1 0-indexed)
  sort?: string;               // "field,direction" e.g., "status,desc"
  search?: string;             // search term
  status?: QuoteStatus;        // filter by status
  account?: 'user' | 'partner'; // scope filter
}

// New validation functions
function validateLimit(limit?: number): number {
  const DEFAULT_LIMIT = 10;
  const MIN_LIMIT = 1;
  const MAX_LIMIT = 50;
  
  if (limit === undefined) return DEFAULT_LIMIT;
  if (!Number.isInteger(limit) || limit < MIN_LIMIT || limit > MAX_LIMIT) {
    throw new TypeError(`limit must be integer ${MIN_LIMIT}-${MAX_LIMIT}`);
  }
  return limit;
}

function validateV2Page(page?: number): number {
  const DEFAULT_PAGE = 1;  // 1-indexed for v2
  
  if (page === undefined) return DEFAULT_PAGE;
  if (!Number.isInteger(page) || page < 1) {
    throw new TypeError('page must be positive integer');
  }
  return page;
}
```

**Rationale**: 
1. Mirrors Pax8 v2 API exactly per clarification
2. Different constants from v1 require separate validators
3. 1-indexed pages must be documented clearly

**Alternatives Considered**:
- Normalize to v1 style internally: Would confuse developers comparing to Pax8 docs

---

### 5. Quote List Response Structure

**Question**: What is the response structure for listing quotes?

**Decision**: Use the v2-specific paginated response with status counts.

**Findings**: From official OpenAPI:

```typescript
interface QuoteListResponse {
  content: Quote[];
  statusCounts: QuoteStatusCounts;
  page: V2PageInfo;
}

interface QuoteStatusCounts {
  draft: number;
  assigned: number;
  sent: number;
  closed: number;
  declined: number;
  accepted: number;
  changes_requested: number;
  expired: number;
}

interface V2PageInfo {
  limit: number;
  page: number;
  totalElements: number;
  totalPages: number;
}
```

**Rationale**: This differs from v1's `PagedResponse<T>` structure - v2 includes `statusCounts` at list level.

**Alternatives Considered**: None - must match API response.

---

### 6. Line Item Response vs Quote Response

**Question**: How are line items returned after add/update operations?

**Decision**: Line item operations return the full Quote object.

**Findings**: From official OpenAPI:
- `POST /v2/quotes/{quoteId}/line-items` returns `Quote` (not `LineItem[]`)
- `PUT /v2/quotes/{quoteId}/line-items` returns `Quote`
- Delete operations return 204 No Content

**Rationale**: Server recalculates totals after line item changes; returning full quote ensures client has updated totals.

**Alternatives Considered**: None - follows API contract.

---

### 7. Section Operations Structure

**Question**: How do section operations work?

**Decision**: Sections are managed as a batch on the quote.

**Findings**: From official OpenAPI:
- `GET /v2/quotes/{quoteId}/sections` returns `Section[]`
- `POST /v2/quotes/{quoteId}/sections` creates section, returns `Section[]`
- `PUT /v2/quotes/{quoteId}/sections` updates all sections (batch), returns `Section[]`

```typescript
interface Section {
  id: string;                   // UUID
  name: string;
  order: number;
  lineItems: SectionLineItem[]; // references to line items
}

interface SectionLineItem {
  lineItemId: string;          // UUID
  order: number;
}

interface CreateSectionPayload {
  name: string;
}

interface UpdateSectionsPayload {
  sections: UpdateSectionItem[];
}

interface UpdateSectionItem {
  id: string;
  name?: string;
  order?: number;
  lineItems?: SectionLineItem[];
}
```

**Rationale**: Batch update allows reordering multiple sections atomically.

**Alternatives Considered**: None - follows API contract.

---

### 8. Access List Operations

**Question**: How are access list entries managed?

**Decision**: Standard CRUD with email-based creation.

**Findings**: From official OpenAPI:

```typescript
interface AccessListEntry {
  id: string;                  // UUID
  email: string;               // recipient email
  link: string;                // unique access URL
  userId: string | null;       // associated user if registered
}

interface AddAccessListPayload {
  emails: string[];            // 1 or more emails
}
```

- Adding duplicate email returns `QUOTE_ACCESS_EMAIL_EXISTS` error
- Each entry gets unique `link` for quote access
- Delete removes entry by ID (not email)

**Rationale**: Email-based for convenience; ID-based delete for precision.

**Alternatives Considered**: None - follows API contract.

---

### 9. Quote Preferences Endpoint

**Question**: How do quote preferences work?

**Decision**: Partner-level settings with GET/PUT at `/v2/quote-preferences`.

**Findings**: From official OpenAPI:

```typescript
interface QuotePreferences {
  daysToExpire: number;        // default expiration days
  introMessage: string;        // default intro message
  termsAndDisclaimers: string; // default terms
}

// PUT creates if not exists (returns 201 or 200)
// GET returns current preferences
```

**Rationale**: Separate endpoint from quotes; affects defaults for new quotes.

**Alternatives Considered**: None - follows API contract.

---

### 10. Error Type Enumeration

**Question**: What error types does the v2 API return?

**Decision**: Map error types to client error handling.

**Findings**: From official OpenAPI:

```typescript
type QuoteErrorType =
  | 'QUOTE_NOT_FOUND'
  | 'QUOTE_VALIDATION'
  | 'LINE_ITEM_LIMIT_EXCEEDED'
  | 'QUOTE_ACCESS_EMAIL_EXISTS'
  | 'ACCESS_DENIED'
  | 'INVALID_REQUEST_PARAMETER'
  | 'REQUEST_VALIDATION_FAILED'
  | 'PAYLOAD_VALIDATION'
  | 'SERVICE_UNAVAILABLE';

interface QuoteApiError {
  status: number;
  message: string;
  type: QuoteErrorType;
  instance: string;            // request ID
  details: ErrorDetail[];
}

interface ErrorDetail {
  field?: string;
  message: string;
}
```

**Rationale**: Consistent error structure for client error handling.

**Alternatives Considered**: None - follows API contract.

---

## Summary

All technical questions resolved. Key decisions:
1. **Discriminated unions** for line item types with `type` literal
2. **Single client** with v2 path prefix for quotes endpoints
3. **New pagination validators** for `limit/page` (1-indexed)
4. **v2-specific response types** with `statusCounts`
5. **Batch section updates** for atomic reordering
6. **Email-based access list** creation with ID-based deletion
